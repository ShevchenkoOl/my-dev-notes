// fetch() — это встроеная функция в браузер которая помагает взаемодействовать клиент-сервер. Кроме этого это современный стандартный способ делать сетевые запросы в браузере без использования сторонних библиотек.

// Базовый синтаксис:
// function getAPI() {
//   showSpinner();     // если есть спинер
//   return fetch(URL)
//     .then(response => {
//       // ПРОВЕРКА: если статус не 200-299, выкидываем ошибку вручную
//       if (!response.ok) {
//         throw new Error(`Ошибка сервера: ${response.status}`);
//       }
//       return response.json();
//     })
//     .then(data => {
//       // Тут работаем с данными
//       console.log(data);
//     })
//     .catch(error => {
//       console.error("Error:", error.message);  // срабатывает только если произошла сетевая ошибка: пропал интернет, заблокировали запрос (CORS), сервер вообще не существует или адрес написан с ошибкой
//     })
//     .finally(hideSpinner);  // срабатывет не зависимо от того что произойдёт выше или ошибка или всё произойдёт ок.
// };




// Более современый способ, это перевести функции в fetch в асихронную с помощью конструкции async/await, то есть внутри неё можно «ставить код на паузу».

// Ключевое слово async: Мы помечаем функцию как асинхронную. Это значит, что внутри неё можно «ставить код на паузу».
// Ключевое слово await: Оно буквально говорит интерпретатору: «Подожди, пока придет ответ от сервера, и только потом иди к следующей строке».
// Блок try...catch: Вместо цепочки методов .then().catch(), мы используем стандартную конструкцию для обработки ошибок, которая знакома многим по другим языкам программирования.

// async function getAPI() {
//   try {
//     showSpinner();
    
//     // Ждем, пока выполнится сетевой запрос
//     const response = await fetch(URL);

//     // Проверяем статус (как мы обсуждали выше)
//     if (!response.ok) {
//       throw new Error(`Ошибка: ${response.status}`);
//     }

//     // Ждем, пока данные превратятся в JSON
//     const data = await response.json();
    
//     console.log(data);
//     return data;

//   } catch (error) {
//     // Сюда попадут и сетевые ошибки, и наши ошибки 404/500
//     console.error("Error:", error.message);
//   } finally {
//     hideSpinner();
//   }
// };



// Использование библиотеки Axios:
// - Преобразует автоматически JSON;
// - Обрабатывание ошибок 400 и 500 автоматически отправляет в catch;
// - Имеет встроенную защиту от CSRF атак (fetch() - нужно настраивать доаолнительно)
// CSRF (Cross-Site Request Forgery) — это тип веб-атаки, при котором злоумышленник заставляет браузер авторизованного пользователя выполнить нежелательное действие на доверенном сайте без его ведома.

// npm i axios
import axios from 'axios';

async function getAPI() {
  try {
    showSpinner();
    
    // В Axios данные УЖЕ лежат в объекте data, и он сам парсит JSON
    const response = await axios.get(URL);
    
    console.log(response.data); // Сразу получаем готовый объект
    
  } catch (error) {
    // Axios САМ перехватывает ошибки 404, 500 и прочие
    // Не нужно писать вручную if (!response.ok)
    console.error("Error:", error.response ? error.response.status : error.message);
  } finally {
    hideSpinner();
  }
};


